---
title: 《MySQL实战45讲》 学习笔记
date: 2021-10-11 21:54:36
description: ["《MySQL实战45讲》 学习笔记"]
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true,则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话,就可以在设置password的值,该值必须是用SHA256加密后的密码,防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: false
summary:
categories:
  - 学习
  - MySQL
  - MySQL实战45讲
tags:
  - MySQL
---



>   准备好好学习下 MySQL 了，一直以来对其了解只限于粗浅的使用，买了个[《MySQL实战45讲》](https://time.geekbang.org/column/intro/100020801)系统了解下MySQL。也不会特别深入，在全局视野知道MySQL都有哪些东西就好了。
>
>   这个系列课程感觉还是有很多干货的，每篇下面的思考题，以及评论区的互动都有学习价值。

# 开篇词 | 这一次，让我们一起来搞懂MySQL

>   没啥好说的。

# 01 | 基础架构：一条SQL查询语句是如何执行的？

-   SELECT 语句的执行过程。

![0d2070e8f84c4801adbfa03bda1f98d9](https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/10/11/20211011220109.png)

1.   MySQL 的框架有几个组件，各是什么作用？

     1.   连接器：负责跟客户端建立链接、获取权限、维持和管理链接
     2.   查询缓存：查询请求先访问缓存（key 是查询的语句， value 是查询的结果）。命中直接返回。不推荐使用缓存，表中有数据更新就会清除这个表的缓存数据。（MySQL 8.0 以后直接没有缓存了） 
          -   关闭缓存： `query_cache_type`设置成`DEMAND`
     3.   分析器：对 SQL 语句做解析，判断SQL是否正确
     4.   优化器：决定使用哪个索引，多表关联（join）的时候，决定各个表的连接顺序
     5.   执行期：执行语句，先判断用户有无查询权限，使用表定义的存储引擎执行。

2.   Server层和存储引擎层各是什么作用？

     server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多核心服务功能，以及所有内置函数（如日期、时间、数学和加密函数等），所有夸存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

     存储引擎层负责数据的存储和提取。其架构模式是插件模式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB， 它从MySQL 5.5.5 版本开始成为默认的存储引擎。

3.   `you have an error in your SQL syntax` 这个报错是在词法分析里还是在语法分析里？

     词法分析

4.   对于表的操作权限验证在哪里进行？

     执行器

5.   执行器的执行查询语句的流程是什么样的？

     1.   调用 InnoDB 引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存储在结果集中。
     2.   调用引擎接口取“下一行”，重复相同的判断逻辑，直到取这个表的最后一行。
     3.   执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

---

# 02 | 日志系统：一条SQL更新语句是如何执行的？

更新操作首先要把旧的数据查询出来，所以根据WHERE条件走一遍SELECT的过程，

![0d2070e8f84c4801adbfa03bda1f98d9](https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/10/11/20211011222209.png)

查出来之后更新就好了。本身是一个事物操作。

但是为了保证MySQL的crash-safe，引入了redo log，redo log 和 bin log一起组成两阶段提交机制。

![2e5bff4910ec189fe1ee6e2ecc7b4bbe](https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/10/11/20211011222248.png)

带着大佬总结的问题记笔记。

1.   redo log的概念是什么？为什么会存在？

     redo log 是重做日志，是属于 InnoDB 的日志。。主要用于MySQL异常重启后的一种数据恢复手段，确保了数据的一致性。归根到底是MySQL为了实现WAL机制的一种手段。因为MySQL进行更新操作，为了能够快速响应，所以采取了异步写磁盘写入内存后就返回的策略。但是会存在crash后内存数据丢失的隐患，redo log 具备了crash-safe能力。

2.   什么事WAL（write-ahead log）机制，好处是什么？

     WAL机制事写前日志，也就是MySQL更新操作后在真正把数据写入磁盘前就先记录日志。好处是不用每一次操作都实时把数据写盘，就算crash后也可以通过redo log重放恢复，达到快速响应SQL的目的。

3.   redo log 为什么可以保证crash-safe？

     redo log 是在事务提交前先写入的，redo log 的内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log重放就可以恢复数据。（redo log 是环形写入的，如果写满了会真正进行写盘的）

4.   binlog的概念是什么？起到什么作用？可以做crash-safe嘛？

     binlog 是归档日志，属于MySQL Server层的日志。可以起到全量备份的作用。当需要恢复数据时，可以取出某个时间段内的bin log进行重放恢复。但是bin log不可以做crash-safe，因为crash之前，可能还没有写完 binlog MySQL就宕掉了。所以需要配合redo log 才可以进行crash-safe。

5.   bin log 和 redo log的不同点有哪些？

     bin log 是服务层的，追加写不会覆盖，记录了逻辑变化，是逻辑日志。

     rego log 是引擎层的，循环写满了会覆盖，记录了基于页的物理变化，是物理日志，具备crash-safe操作。

6.   物理一致性和逻辑一致性各应该怎么理解？

     >   TODO 不是很确定

     物理一致性：在实际物理存储中没有差别。
     逻辑一致性（logical consistency）与矛盾（Contradiction）相对；
     也即逻辑上的一致（logically consistent）＝ 没有逻辑矛盾（no logical contraction）

7.   执行器和InnoDB在执行update语句时候的流程是什么样的？

     执行器在优化器选择索引后，调用InnoDb的读接口，读取要更新的行到内存中，执行SQL操作后，更新到内存中，然后写redo log，在写bin log，此时InnoDB会在合适的时候把此次操作的结果写入磁盘。

8.   如果数据库误操作，如何执行数据恢复？

     如果数据库在某一天误操作，就可以找到距离误操作最近时间点前的bin log，重放到临时数据库里，然后选择当天误操作的数据恢复到线上数据库。

9.   *什么是两阶段提交？为什么需要两阶段提交？两阶段提交怎么保证数据库中两份日志间的逻辑一致性？

     先写入redo log 处于prepare阶段，然后写入bin log，最后在redo log中提交变成commit状态。

     如果不用两阶段提交会出现问题（UPDATE SET a=2  table_name WERE a=1）

     	1. 先写 redo log 后写 bin log。假设这次更新操作写完了redo log，没写bin log时MySQL就崩溃了，重起恢复时会加载redo log，当前实例数据是正常的a=2，但因为bin log没有这次操作记录，在进行备份的时候数据的状态就不一样了还是a=1。
     	2. 先写bin log，后写redo log。假设这次更新操作写完了bin log，没写完redo log时MySQL就崩溃了，重新恢复时加载redo log后a的值还是1。再之后用bin log来恢复的时候a的值又回变成2.

     redo log变成commit状态时bin log一定写完了，两边的逻辑一定是一致的。

10.   如果不是两阶段， 先写redo log和先写bin log两种情况会遇到什么问题？

      见上题

---

# 03 | 事务隔离：为什么你改了我还看不见？

## 1. 事物的特性：

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

## 2. 多事物同时执行的时候，可能会出现的问题：

脏读、不可重复读、幻读。

## 3. 事物的隔离级别

-   读未提交（read uncommitted）：一个事物还没提交时，它做的变更就能被其他的事物看到
-   读提交（read committed）：一个 事物提交后，它做的变更**才**能被其他的事物看到
-   可重复读（repeatable read）：一个事物之行过程中看到的数据，总是跟这个食物在启动时看到的是一致的。未提交的更改对其他事物不可见。
-   串行化（serializable ）：对于同一行距离，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

具体使用哪个隔离级别可以看数据库的`transaction_isolation`参数配置。

## 4. 事物并行会产生的问题

脏读：

当一个数据库中一个事物A正在修改一个数据但是还未提交或者回滚，另一个事物B来读取了修改后的数据并使用了。

此情况仅会发生在： 读未提交的的隔离级别.

不可重复读：

在一个事物A中多次操作数据，在事物操作过程中（未提交），事物B也才做了处理，并且该值发生了改变，这时候就会导致A在事物操作的时候发现数据与第一次不一样了。

此情况仅会发生在：读未提交、读提交的隔离级别

幻读：

一个事物按相同的查询条件重新读取以前检索过的数据，却发现其他事物插入了满足其查询条件的新数据。

幻读史之当事物不是独立执行时发生的一种现象，例如一个事物对一个表中的数据进行了修改，比如这种修改设计到表中的全部数据行。同时第二个事物也修改这个表中的数据，这种修改时向表中插入一行新数据。那么就会发生第一个事物的用户发现表中还存在没有修改的数据行，就好像发生了幻觉一样。

一般解决幻读的方法是增加范围锁，锁定检查范围为只读，

此情况会发生在：读未提交、读提交、可重复读的隔离级别.



    事务隔离级别  脏读  不可重复读  幻读
    读未提交（read-uncommitted）  是  是  是
    读已提交（read-committed）  否  是  是
    可重复读（repeatable-read）  否  否  是
    串行化（serializable）  否  否  否

## 5. 事物隔离的实现

每条记录在更新的时候都会同时记录一条回滚操作，同一条记录在系统中可以存在多个版本。这就是数据库的多版本并发控制（MVCC）。

### 回滚日志

更新操作会在回滚日志记一条回滚操作，众多记录构成不同的read-view。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

![d9c313809e5ac148fc39feff532f0fee](https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/10/12/20211012004436.png)

每个事物查询的时候都会到根据该事物启动的时刻读取当时时刻的read-view。

#### 回滚日志的删除

回滚日志总不能一直保留，在不需要的时候，也就是系统判断宕没有事物在需要用到这些回滚日志是，就会把这些回滚日志删除。

>   具体实现时会有事物ID。

## 6. 事物的启动方式

1.   显式启动事物语句 `begin` 或者`start transaction` 提交 `commit`。回滚`rollback`

2.   `set autocommit=0`该命令会把这个线程的自动提交关掉，这样只要之行一个`SELECT`语句，事物就会启动，并不会自动提交，知道主动`commit` 或者 `rollback`或者断开链接。

建议显示启动事物。 如果考虑多一次commit交互问题，可以使用`commit work and chain`语法，可以提交事物并自动启动下一个事物。

## 7. 长事物

### 长事物的问题

长事物存在时系统里面会存在很老的事物视图，在这个食物提交之前，回滚记录都要保留，这回占用大量存储空间。

长事物占用锁和链接资源，增大锁冲突的记录，使连接数占用增加，最终影响服务器性能。



### 长事物该如何避免

从应用开发段看：

1.   确认是否使用了`set autocommit=0`。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。
2.   确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。
3.   业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。

从数据库端看：

1.   监控 `information_schema.innodb_trx`表，设置长事物阈值，超过就**报警**或者**kill**。
2.   Percona 的 pt-ill 工具
3.   在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题
4.   如果是MySQL 5.6或者更新的版本，把 `innodb_undo_tablespaces`设置成2（或者更大的值）。如果真的出现大事物导致的回滚段过大，这样设置后清理起来更方便。

---

# 04 | 深入浅出索引（上）

## 1. 索引的作用

提高数据查询的效率

## 2. 常见的索引模型

1.   哈希表

     key-value形式，把值放到数组里面，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。

     哈希冲突的解决方式：开链法，

     只适用等值查询的场景。

2.   有序数组

     按顺序存储。查询使用二分法，时间复杂度是`O(log(N))`.

     更新效率低，线性的。

     适用于静态数据存储（不需要更新）场景。

3.   搜索树

     二叉搜索树

     ​	每个节点的左儿子小于父节点，父节点又小于右儿子。

     ​	查询时间复杂度O(log(N))，更新时间复杂度O(log(N))。



InnoDB中的索引模型：**B+Tree**

​	B+Tree 是一个N叉树，N差不多是1200，树高小，读盘次数小。

## 3. 索引类型

### 1. 主键索引与非主键索引

主键索引存储的是整行的数据（聚簇索引），非主键索引存储的主键的值（二级索引）。

主键索引只要所搜主键所在的这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，在到主键索引搜索一次（回表）。

### 2. 索引的维护

当一个数据页满了是，按照B+Tree算法，会申请一个新的数据页，挪动部分数据过去，这个过程叫做**页分裂**。这种情况下性能会下降，空间利用路降低大概50%。当相邻的数据页利用率很低的时候会做数据页合并，合并过程是分裂过程的逆过程。

从性能和存储空间方面考量，自增主键往往是更合理的选择。 自增主键每新加一行，都会在尾部追加。

---

# 05 | 深入浅出索引（下）

## 1. 索引覆盖

如果查询条件使用的是普通索引（或者联合索引的最左原则字段），查询结果是联合索引的字段或者主键，就不需要回表操作，可以直接返回结果，减少磁盘IO。

## 2. 最左前缀

联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

## 3. 联合索引

根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以`age=1`或`age=1 and name='张三'`可以使用索引，单以`name='张三'`不可以使用索引。考虑到存储空间的问题，需要根据业务诉求，将查找频繁的数据进行靠左创建索引。

## 4. 索引下推

类似`like 'hello%' and age > 10`的检索，MySQL 5.6 版本之前会对匹配的数据进行回表查询。 5.6版本之后会先过滤掉`age<10`的数据，在进行回表查询，减少回表率，提升检索速度。

---

# 06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

MySQL中的锁大致分成**全局锁**、**表级锁**和**行锁**三类

## 1. 全局锁

### 1. 全局锁是什么

全局锁就是对整个数据库实例加锁。当需要让整个库处于只读状态的时候，可以使用`Flush tables with read lock (FTWRL)`命令。执行这个命令后 **数据更新语句（数据的增删改，DML）**、**数据定义语句（包括建表、修改表结构等，DDL）**和**更新类事物的提交语句**都会被阻塞。

### 2. 全局锁的场景

典型的使用场景是做**全库逻辑备份**。也就是把整库每个表都select出来存成文本。

如果不加全局锁，备份系统备份的时候得到的库不是一个逻辑时间点，这个视图的逻辑不一致。

### 3. 全局锁的风险

1.   如果在主库备份，在备份期间不能更新，业务停摆。

2.   如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟。

     >   MySQL官方自带的逻辑备份工具mysqldump，当mysqldump使用参数--single-transaction的时候，会启动一个事物，确保拿到一执行视图。由于MVCC的支持，这个过程中的数据是可以正常更新的。
     >
     >   **一致性读是好，但前提是引擎要支持这个隔离级别。**

### 4. 全库只读，为什么不使用`set global realonly=true`?

1.   在某些系统中，readonly的值会被用来做其他逻辑，比如判断一个库是主库还是备库。因此修改global变量的影响面更大，不建议使用。
2.   在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到正常可写的状态。将整个库设置成readonly后，客户端异常后，数据库还是会保持readonly状态。会导致整个库长时间不可写，风险高。

## 2. 表级锁

### 1. 两类表级锁。

1.   表锁

     表锁的语法是`lock tables ... read/write`。与`FTWR`L类似，可以用`unlock tables`主动释放锁，也可以在客户端断开的时候自动释放。需要注意，`lock tables`语法除了会限制别的线程的读写外，也限定了本线程接下来的操作。

2.   元数据锁（meta data lock，MDL）

     MDL不需要显示使用，在访问一个表的时候会被自动加上。

     MDL的作用是**保证读写的正确性**。

     当对一个表进行增删改查操作的时候，加MDL读锁；当对表做结构变更的时候，加MDL写锁。

     -   读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
     -   读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此如果有两个线程要同时给一个表加字段，其中一个要等到另一个执行完才能开始执行。

### 2. 给小表加字段

给小表加字段是对表结构变更，会加MDL写锁。

如果之前有事物A搞了MDL读锁，事物没有提交。然后就进行修改表结构，因为加了写锁，所以会被阻塞。如果后面事物A又进行增删改查操作需要申请读锁，就会被锁住，这个表就完全不可读写了。
		客户端又重试机制，超时后会仔起session进行请求，这个库的线程很快就爆满了。

>    那么如何安全地给小表加字段呢？
>
>   比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

---

