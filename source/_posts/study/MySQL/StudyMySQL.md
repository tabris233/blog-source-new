---
title: 《MySQL实战45讲》 学习笔记
date: 2021-10-11 21:54:36
description: ["《MySQL实战45讲》 学习笔记"]
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true,则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话,就可以在设置password的值,该值必须是用SHA256加密后的密码,防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: false
summary:
categories:
  - 学习
  - MySQL
  - MySQL实战45讲
tags:
  - MySQL
---



>   准备好好学习下 MySQL 了，一直以来对其了解只限于粗浅的使用，买了个[《MySQL实战45讲》](https://time.geekbang.org/column/intro/100020801)系统了解下MySQL。

# 开篇词 | 这一次，让我们一起来搞懂MySQL

>   没啥好说的。

# 01 | 基础架构：一条SQL查询语句是如何执行的？

-   SELECT 语句的执行过程。

![0d2070e8f84c4801adbfa03bda1f98d9](https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/10/11/20211011220109.png)

1.   MySQL 的框架有几个组件，各是什么作用？

     1.   连接器：负责跟客户端建立链接、获取权限、维持和管理链接
     2.   查询缓存：查询请求先访问缓存（key 是查询的语句， value 是查询的结果）。命中直接返回。不推荐使用缓存，表中有数据更新就会清除这个表的缓存数据。（MySQL 8.0 以后直接没有缓存了） 
          -   关闭缓存： `query_cache_type`设置成`DEMAND`
     3.   分析器：对 SQL 语句做解析，判断SQL是否正确
     4.   优化器：决定使用哪个索引，多表关联（join）的时候，决定各个表的连接顺序
     5.   执行期：执行语句，先判断用户有无查询权限，使用表定义的存储引擎执行。

2.   Server层和存储引擎层各是什么作用？

     server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多核心服务功能，以及所有内置函数（如日期、时间、数学和加密函数等），所有夸存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

     存储引擎层负责数据的存储和提取。其架构模式是插件模式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB， 它从MySQL 5.5.5 版本开始成为默认的存储引擎。

3.   `you have an error in your SQL syntax` 这个报错是在词法分析里还是在语法分析里？

     词法分析

4.   对于表的操作权限验证在哪里进行？

     执行器

5.   执行器的执行查询语句的流程是什么样的？

     1.   调用 InnoDB 引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存储在结果集中。
     2.   调用引擎接口取“下一行”，重复相同的判断逻辑，直到取这个表的最后一行。
     3.   执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

---

# 02 | 日志系统：一条SQL更新语句是如何执行的？

更新操作首先要把旧的数据查询出来，所以根据WHERE条件走一遍SELECT的过程，

![0d2070e8f84c4801adbfa03bda1f98d9](https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/10/11/20211011222209.png)

查出来之后更新就好了。本身是一个事物操作。

但是为了保证MySQL的crash-safe，引入了redo log，redo log 和 bin log一起组成两阶段提交机制。

![2e5bff4910ec189fe1ee6e2ecc7b4bbe](https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/10/11/20211011222248.png)

带着大佬总结的问题记笔记。

1.   redo log的概念是什么？为什么会存在？

     redo log 是重做日志，是属于 InnoDB 的日志。。主要用于MySQL异常重启后的一种数据恢复手段，确保了数据的一致性。归根到底是MySQL为了实现WAL机制的一种手段。因为MySQL进行更新操作，为了能够快速响应，所以采取了异步写磁盘写入内存后就返回的策略。但是会存在crash后内存数据丢失的隐患，redo log 具备了crash-safe能力。

2.   什么事WAL（write-ahead log）机制，好处是什么？

     WAL机制事写前日志，也就是MySQL更新操作后在真正把数据写入磁盘前就先记录日志。好处是不用每一次操作都实时把数据写盘，就算crash后也可以通过redo log重放恢复，达到快速响应SQL的目的。

3.   redo log 为什么可以保证crash-safe？

     redo log 是在事务提交前先写入的，redo log 的内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log重放就可以恢复数据。（redo log 是环形写入的，如果写满了会真正进行写盘的）

4.   binlog的概念是什么？起到什么作用？可以做crash-safe嘛？

     binlog 是归档日志，属于MySQL Server层的日志。可以起到全量备份的作用。当需要恢复数据时，可以取出某个时间段内的bin log进行重放恢复。但是bin log不可以做crash-safe，因为crash之前，可能还没有写完 binlog MySQL就宕掉了。所以需要配合redo log 才可以进行crash-safe。

5.   bin log 和 redo log的不同点有哪些？

     bin log 是服务层的，追加写不会覆盖，记录了逻辑变化，是逻辑日志。

     rego log 是引擎层的，循环写满了会覆盖，记录了基于页的物理变化，是物理日志，具备crash-safe操作。

6.   物理一致性和逻辑一致性各应该怎么理解？

     >   TODO 不是很确定

     物理一致性：在实际物理存储中没有差别。
     逻辑一致性（logical consistency）与矛盾（Contradiction）相对；
     也即逻辑上的一致（logically consistent）＝ 没有逻辑矛盾（no logical contraction）

7.   执行器和InnoDB在执行update语句时候的流程是什么样的？

     执行器在优化器选择索引后，调用InnoDb的读接口，读取要更新的行到内存中，执行SQL操作后，更新到内存中，然后写redo log，在写bin log，此时InnoDB会在合适的时候把此次操作的结果写入磁盘。

8.   如果数据库误操作，如何执行数据恢复？

     如果数据库在某一天误操作，就可以找到距离误操作最近时间点前的bin log，重放到临时数据库里，然后选择当天误操作的数据恢复到线上数据库。

9.   *什么是两阶段提交？为什么需要两阶段提交？两阶段提交怎么保证数据库中两份日志间的逻辑一致性？

     先写入redo log 处于prepare阶段，然后写入bin log，最后在redo log中提交变成commit状态。

     如果不用两阶段提交会出现问题（UPDATE SET a=2  table_name WERE a=1）

     	1. 先写 redo log 后写 bin log。假设这次更新操作写完了redo log，没写bin log时MySQL就崩溃了，重起恢复时会加载redo log，当前实例数据是正常的a=2，但因为bin log没有这次操作记录，在进行备份的时候数据的状态就不一样了还是a=1。
     	2. 先写bin log，后写redo log。假设这次更新操作写完了bin log，没写完redo log时MySQL就崩溃了，重新恢复时加载redo log后a的值还是1。再之后用bin log来恢复的时候a的值又回变成2.

     redo log变成commit状态时bin log一定写完了，两边的逻辑一定是一致的。

10.   如果不是两阶段， 先写redo log和先写bin log两种情况会遇到什么问题？

      见上题

---

# 03 | 事务隔离：为什么你改了我还看不见？

## 1. 事物的特性：

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

## 2. 多事物同时执行的时候，可能会出现的问题：

脏读、不可重复读、幻读。

## 3. 事物的隔离级别

-   读未提交（read uncommitted）：一个事物还没提交时，它做的变更就能被其他的事物看到
-   读提交（read committed）：一个 事物提交后，它做的变更**才**能被其他的事物看到
-   可重复读（repeatable read）：一个事物之行过程中看到的数据，总是跟这个食物在启动时看到的是一致的。未提交的更改对其他事物不可见。
-   串行化（serializable ）：对于同一行距离，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

具体使用哪个隔离级别可以看数据库的`transaction_isolation`参数配置。

## 4. 事物并行会产生的问题

脏读：

当一个数据库中一个事物A正在修改一个数据但是还未提交或者回滚，另一个事物B来读取了修改后的数据并使用了。

此情况仅会发生在： 读未提交的的隔离级别.

不可重复读：

在一个事物A中多次操作数据，在事物操作过程中（未提交），事物B也才做了处理，并且该值发生了改变，这时候就会导致A在事物操作的时候发现数据与第一次不一样了。

此情况仅会发生在：读未提交、读提交的隔离级别

幻读：

一个事物按相同的查询条件重新读取以前检索过的数据，却发现其他事物插入了满足其查询条件的新数据。

幻读史之当事物不是独立执行时发生的一种现象，例如一个事物对一个表中的数据进行了修改，比如这种修改设计到表中的全部数据行。同时第二个事物也修改这个表中的数据，这种修改时向表中插入一行新数据。那么就会发生第一个事物的用户发现表中还存在没有修改的数据行，就好像发生了幻觉一样。

一般解决幻读的方法是增加范围锁，锁定检查范围为只读，

此情况会发生在：读未提交、读提交、可重复读的隔离级别.



    事务隔离级别  脏读  不可重复读  幻读
    读未提交（read-uncommitted）  是  是  是
    读已提交（read-committed）  否  是  是
    可重复读（repeatable-read）  否  否  是
    串行化（serializable）  否  否  否

## 5. 事物隔离的实现

每条记录在更新的时候都会同时记录一条回滚操作，同一条记录在系统中可以存在多个版本。这就是数据库的多版本并发控制（MVCC）。

### 回滚日志

更新操作会在回滚日志记一条回滚操作，众多记录构成不同的read-view。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

![d9c313809e5ac148fc39feff532f0fee](https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/10/12/20211012004436.png)

每个事物查询的时候都会到根据该事物启动的时刻读取当时时刻的read-view。

#### 回滚日志的删除

回滚日志总不能一直保留，在不需要的时候，也就是系统判断宕没有事物在需要用到这些回滚日志是，就会把这些回滚日志删除。

>   具体实现时会有事物ID。

## 6. 事物的启动方式

1.   显式启动事物语句 `begin` 或者`start transaction` 提交 `commit`。回滚`rollback`

2.   `set autocommit=0`该命令会把这个线程的自动提交关掉，这样只要之行一个`SELECT`语句，事物就会启动，并不会自动提交，知道主动`commit` 或者 `rollback`或者断开链接。

建议显示启动事物。 如果考虑多一次commit交互问题，可以使用`commit work and chain`语法，可以提交事物并自动启动下一个事物。

## 7. 长事物

### 长事物的问题

长事物存在时系统里面会存在很老的事物视图，在这个食物提交之前，回滚记录都要保留，这回占用大量存储空间。

长事物占用锁和链接资源，增大锁冲突的记录，使连接数占用增加，最终影响服务器性能。



### 长事物该如何避免

从应用开发段看：

1.   确认是否使用了`set autocommit=0`。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。
2.   确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。
3.   业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。

从数据库端看：

1.   监控 `information_schema.innodb_trx`表，设置长事物阈值，超过就**报警**或者**kill**。
2.   Percona 的 pt-ill 工具
3.   在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题
4.   如果是MySQL 5.6或者更新的版本，把 `innodb_undo_tablespaces`设置成2（或者更大的值）。如果真的出现大事物导致的回滚段过大，这样设置后清理起来更方便。
